
python 类知识点总结

	
面向对象思想：
    1、设计的时候，一定要明确应用场景
    2、由对象分析定义类的时候，找不到共同特征和技能不用强求
  
1.简述类、对象、实例化、实例这些名词的含义：
    类：从一组对象中提取对象共同的特征和属性，构成一个类。
    对象：具有数据属性和函数属性的集合体
    实例化：由类生成一个对象的方法，就是实例化
    实例：类的实例化就会产生一个实例（对象）
  
    类：
        对象就是类的抽象
        类实例成对象的过程就是实例化
        实例就是对象
  
2.面向对象的三大特性是什么？
    继承，多态，封装
  
3.什么是方法？类中可以定义哪几种方法？
  
    方法是指可以被类或是对象调用的方法
  
    1、类内部定义的方法，可以绑定到对象
    2、绑定到类的方法，classmethod
    3、静态方法：staticmethod 把类内的属性，转成一个函数
    4、property 将类内的函数属性，伪装成数据属性
    5、私有方法:__x
  
4.什么是属性？类中可以定义哪几种属性？
    属性是指对象共有的特征，类是这些共有特征的集合体，属性有两种：数据属性和函数属性
  
5.请简述类方法和静态方法有哪些区别？
    类方法：是把类内定义的属性，加上类方法的装饰器，使该属性只能被类使用！
    静态方法：把类内的函数属性，转变成一个函数，不再属于类或是对象名称空间内的方法。静态方法必须有固定的传参，类方法自带类的参数，传入的是类的方法
  
6.简述新式类和经典类的区别
    新式类和经典类在继承顺序上有区别；
    新式类是广度优先
    经典类是深度优先
类知识梳理

	
1、类：
 
　　一：实例化，二：引用名字（类名.变量名，类名.函数名） 得到一个内存地址，加()就能运行。
 
2、实例（对象）：
 
　　引用名字(实例名.类的变量，实例名.绑定方法，实例名.实例自己的变量名)
 
3、类：
　　优点：解决了程序的扩展性，对某个对象进行修改，会立刻反映到整个体系中
　　缺点：可控性差，无法预测最终的结果。
　　面向对象的程序设计并不是全部。对于软件质量来说，面向对象的程序设计只是用来解决扩展性的问题。
　　在python中，用变量表示特征，用函数表示方法，因而类是变量与函数的结合体，对象是变量与方法（指向类的函数）的结合体
 
4、类属性：特征（变量）和方法（函数）
 
5、类有两种方法：1.类的实例化；2.属性引用
　　1.实例化：
　　　　类名加括号就是实例化，会自动触发__init__函数的运行，可以用它来为每个实例定制自己的特征
　　2.属性引用：
　　　　类名.方法
 
6、对象也称为实例
　　对象的属性：对象本身就自有特征（变量）。对象只有一种用法：属性引用
 
7、类的名称空间和对象的名称空间
 
　　创建一个类，就会创建一个类的名称空间，存放类中定义的属性：特征（数据）和方法（函数）
　　创建一个对象，及类的实例化，就会创建一个类的名称空间，存放对象的属性。
　　注意：对象就是类的实例化，类完成实例化的操作就已经将类的方法绑定到对象上，对象调用方法会现在自己的名称空间去找，找不到会去类的名称空间去找，再找不到会抛异常。它不会去找全局的定义。
 
　　查看类的名称空间 类名._dict_
　　查看对象的名称空间 对象名._dict_
 
　　绑定方法的核心在于‘绑定’，唯一绑定到一个确定的对象
 
7.5、继承与派生
　　经典类：深度优先
　　新式类：广度优先
　　查看继承顺序（仅在新式类下）：类名.__mro__方法
 
　　派生：子类重定义某个方法，但是部分继承父类中这个方法：
　　1:super(自己的类,self).父类的函数名字
　　2：super只能用于新式类
　　
 
　　1）关于继承中方法引用的问题：
　　Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。
 
　　2）何时使用继承：
　　多个类之间有公共的属性或方法，可以把这些公共的提取出来作为基类，继承基类，同时特殊的方法或属性在自己类内定义。提高了代码的可扩展性！
 
7.6、组合（大类内包含小类）：
 
1、组合认知：
 
　　软件重用的重要方式除了继承之外还有另外一种方式，即：组合。
 
　　组合指的是：在一个类中，部分数据属性是以其他类实例化的对象作为数据属性，称为类的组合
　　简单理解就是：大类中包含小类，就是组合。
　　组合的用于：1、做关联；2、由小的组成大的
 
2、组合和继承的区别：
　　组合与继承都是有效地利用已有类的资源的重要方式。但是二者的概念和使用场景皆不同。
1、继承：
　　通过继承建立了派生类与基类之间的关系，它是一种 '是' 的关系，例如：人是动物。当类之间有很多相同的功能，提取这些共同的功能做成基类，子类实现调用这些功能，还是用继承比较好，比如盖伦是英雄等……
2、组合：
　　用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系，当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好。例如：学生、老师有生日，学生有课程等……
 
8、多态与多态性
 
　　多态（是从定义角度出发）：同一类事物的多种形态。（一个抽象类有多个子类，因而多态的概念依赖于继承）例如：动物的多种形态：人，狗，猪。
　　多态性（是从使用角度出发）：同一种调用方式，不同的执行效果。具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。
　　多态性依赖于：1.继承；2.定义的接口
 
9、封装：
　　1、封装的本质就是隐藏，将一些复杂的执行过程隐藏起来，留下调用的接口（接口就是函数，称为接口函数；一组接口函数的集合体构成一个接口），我们通过这些接口进行交互，不管程序在内部怎么个应用流转方式，只为得到最后的结果。
　　2、数据封装主要原因是：保护隐私；方法封装主要原因是：隔离复杂度。
　　3、封装分为两个层面：但无论哪种层面的封装，都要对外界提供好访问你内部隐藏内容的接口
 
　　第一层面的封装：其实就是创建类或是对象，通过类名.或对象名.的方式调用对应的方法，这本身就是一种封装。
　　　　    注意：对于这一层面的封装（隐藏），类名.和实例名.就是访问隐藏属性的接口
 
　　第二个层面的封装：类中把某些属性和方法隐藏起来(或者说定义成私有的)，只在类的内部使用、外部无法访问，或者留下少量接口（函数）供外部访问。
　　　　1、在python中用双下划线的方式实现隐藏属性（设置成私有的）。类中所有双下划线开头的名称如__x都会自动变形成：_类名__x的形式；
　　　　2、注意：__名字，这种语法只在定义的时候才会有变形的效果，如果类或者对象已经产生了，就不会有变形效果。变形的过程只在类的定义时发生一次；在定义后的赋值操作，就不会变形
　　　　3、在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的。
类型判断：isinstance 和 issubclass
1
2
3
	
1、isinstance(obj,cls)检查是否obj是否是类 cls 的对象。
2、issubclass(sub, super)检查sub类是否是 super 类的派生类。
　　    判断结果为布尔值：是返回True，不是返回False
反射：getattr,setattr,delattr,hasattr

	
1、定义：
　　反射：主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。
　　python面向对象中的反射：通过字符串的形式，操作对象的相关的属性。python中的一切事物都是对象（都可以使用反射）。
 
2、应用：关于传参 第一个是对象，第二个是字符串
 
1) hasattr 查找 判定有没有这个方法
　　hasattr(object,'name') 应用于类或对象，查看有没有所对应的方法。实质还是从类或对象的名称空间去查找。判断结果返回布尔值，有为True,没有为False.
 
2) getattr 获取 获取对象下的方法或属性，如果是方法加括号就能运行，没有就返回自定义的错误信息
　　getattr(object,name，‘返回值’) 通过字符串获取 查看有没有这个属性，获取绑定方法。实质还是从类或对象的名称空间去查找，有的话返回为函数内存地址，加()就能运行。
 
3) setattr 设置 给对象添加某个属性
　　setattr(x,y,v)　　 x=类或对象， y='字符串类型的属性名'，v=value 值 实质是给类或是对象添加数据属性。
 
4) delattr 删除 删除属性
　　delattr(x,y) 　　x = 类或对象，y = '字符串类型的属性名' 删除类或是对象内的某个属性！
 
　　sys.modules[__name__] #利用sys模块中的modules方法，将本文件转成脚本模块 
 
　　反射好处：实现可插拔机制；可以通过字符串判断执行类下某个方法
内置attr：__getattr__,__setattr__,__delattr__   #可以在内置方法中定义操作

大前提：类内部设置
1、__setattr__ #常用于为对象添加属性
1
2
	
语法：def __setattr__(self,key,value):
...

　　 以函数方式，设置在类内部，实例化传值自动触发，会直接获取为对象设置的属性或传参，对应的属性或方法，不会写入对象的名称空间中。 
　　利用此种方法可以加上自己的限制，然后再通过 self.__dict[key]=value 的方法 添加到对象的名称空间中。
2、__delattr__ 　del 对象.属性 触发
1
2
	
语法：def __delattr__(self,item):
                ...

　　 执行删除操作，自动触发，删除对象下某个属性，但实质上不会真正从名称空间里删除。若需要删除的话必须通过 self.__dict__.pop(item) 在名称空间中删除 。

3、__getattr__ （特别注意该内置函数的方法！！！）
1
2
	
语法：def __setattr__(self,key,value):
            ....

　　只有在类内该属性不存在的情况下，才会触发执行，返回None！而类内有对应的方法，就不会执行。
　　常用于继承父类，重写内置函数，对所有需要添加的功能由类中再定义，已存在的功能默认执行。通过 __getattr__ 判断当前类内有没有这个方法；没有直接通过getattr()获取，覆盖 __getattr__ 。实现授权操作！

	
class Foo:
    def __init__(self,x): #初始化属性
        self.name = x
     # self.name = x ------------>  self = self;key = name; value = x
    def __setattr__(self, key, value): # 自动触发，获取self.属性名=值  self = self;key = 属性名;value = 值
        print('---setattr---key:%s,value:%s'%(key,value))
        self.__dict__[key] = value  #在对象的名称空间中添加方法
 
    def __delattr__(self, item):# 删除某项属性
        print('delattr:%s'%item)
        print(f.__dict__)  #打印当前对象的名称空间
        self.__dict__.pop(item)  #删除对象内的方法
 
    def __getattr__(self, item):  # 没有方法触发
        print('getattr---> %s %s'%(item,type(item)))
 
#调用__setattr__的方法
f = Foo('zh')  #类的实例化
f.age = 18  #给类定义一个数据属性
print(f.__dict__)  #打印当前字典
 
#执行结果：
---setattr---key:name,value:zh
---setattr---key:age,value:18
{'name': 'zh', 'age': 18}
 
#调用__delattr__的方法
del f.age
print(f.__dict__)
 
#执行结果：
delattr:age
{'name': 'zh', 'age': 18}
{'name': 'zh'}
 
#调用__getattr__的方法
print(f.name)
print(f.azcw)
 
#执行结果：
zh
getattr---> azcw <class 'str'>
None
__str__：类实例化自动触发，改变类实例化对象显示的名字。
1
2
	
def __str__(self): #定义在类内部，必须返回一个字符串类型。
    return #什么时候会触发执行：打印由这个类产生的对象时，才会触发执行。类内调用，必须返回值（字符串），打印结果。
property,staticmethod,classmethod

　　1、property：把类内函数属性，伪装成数据属性，通过点的方式调用。
　　2、classmethod : 类方法 把类内某个方法，转变成类方法，仅能是类去调用，不再存在于对象的名称空间
　　3、staticmethod: 静态方法 将绑定解除转变成一个普通的函数，不再属于任何一个类或对象。

	
1.什么是绑定到对象的方法，如何定义，如何调用，给谁用？有什么特性
     
    答：绑定到对象的方法是类内部定义的，并且没有被装饰器修饰过的方法，类实例化成产生的对象可以直接调用类内部的函数。
         定义方式：
            class A:
                def test(self): #绑定到对象的方法
                    pass
            a = A() #生成一个对象
    调用方式：a.test()  对象.对象的绑定方法()  给对象调用
    特性：调用的时候，会把对象作为第一个参数传给对象的绑定方法。
     
2.什么是绑定到类的方法，如何定义，如何调用，给谁用？有什么特性
    答：通过 classmethod 进行绑定到类的方法操作，定义在类内部的函数，并且被@ classmethod修饰过的方法，就是绑定到类的方法。
            定义方式：
            class B:
                @ classmethod
                def func(cls): #绑定到类的方法
                    pass
             class C:
                def func2(self):
                    pass
            c = C()
            B.func() 
            c.func()
    通过 类 或是生成的 对象调用，不管怎样最后还是绑定到类的方法，调用的还是操作类的本身。
    特性：调用的时候，会把类作为第一个参数传给类的绑定方法。
 
3.什么是解除绑定的函数，如何定义，如何调用，给谁用？有什么特性
    答：通过 staticmethod进行解除绑定到类的方法操作，定义在类内部的函数，并且被@ staticmethod修饰过的方法，就是解除绑定的方法。类内定义的函数既不与类绑定，也不与对象绑定。
        定义方式：
            class D:
                @ staticmethod
                def func3(name,age): #解除绑定
                    pass
            D.func3(name,age)  #调用方式
    此时类内的函数就是普通的函数，不管是类还是实例化的对象都可以使用，不再属于谁的绑定方法，就是一个函数。
    特性：由于是函数，就需要手动定义位置参数，调用的时候也需要传值。
4.什么是property，如何定义，如何使用，给谁用，什么情况下应该将一个属性定义成property，有什么好处？
    通过property 特性就是把类内部函数进行伪装，定义在类内部的函数，并且被@ property修饰，就是把这个函数属性伪装成数据属性，统一了使用者的调用规则，也实现了封装。
    定义方式：
        class E:
            @property
            def func4(self):
                pass
        E.func4  #调用方式
    property方法一般常用于隐藏数据属性的方法上，同时可以通过添加添加setter或deleter的方法对隐藏属性进行更改或是删除。
    好处：被property装饰的属性会优先于对象的属性被使用
__slots__ 指定类可定义的属性或方法
1
2
3
4
5
6
7
8
9
10
11
	
　　1、__slots__是什么: 是一个类变量,变量值可以是列表,元组,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性)
 
　　2、为何使用__slots__:名称空间的字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__。当你定义__slots__后,__slots__就会为实例使用一种更加紧凑的属性表示方式。实例会通过一个很小的固定大小的数组来构建内部方法,而不再是为每个实例定义一个字典,这跟元组或列表很类似。
__slots__中列出的属性名在内部被映射到这个数组的指定下标上。使用__slots__一个不好的地方就是我们不能再给实例添加新的属性了,只能使用在__slots__中定义的那些属性名。
 
　　3、注意事项:
　　　　1）定义了__slots__ 属性的类，仅在当前类下有名称空间，通过类名.__dict__查看，但也仅是通过__slots__定义的属性；该类实例化产生的对象不再有名称空间，方法也仅是在__slots__中定义的那几个。
 
　　　　2）定义了__slots__后的类不再支持一些普通类特性了,比如多继承。大多数情况下,你应该只在那些经常被使用到的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象 。
 
　　4、好处：节省内存：类内部指定属性，对象就只能建立所对应的属性。不再有属性字典__dict__,统一归__slots__管。
__next__ 和 __iter__ 用以实现迭代器 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
	
class Range:
 
    def __init__(self,start,end):
        self.start = start
        self.end = end
 
    def __iter__(self): #将对象转变成迭代器
        return self
 
    def __next__(self): #自取值
        if self.start == self.end:
            raise StopIteration
 
        n = self.start
        self.start+=1
        return n
 
for i in Range(1,10):
    print(i)
__doc__ 、__module__ 、__class__

__doc__描述信息，该属性无法被继承，是对本函数或类的描述！没写打印None

__module__ 表示当前操作的对象在哪个模块
__class__ 表示当前操作的对象的类是什么
__del__ 析构函数 

　　删除对象或是对象执行完回收，引用计数为0的时候，自动触发执行，将对象在内存中释放。
　　注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。

　　在类中定义 __del__ 一般是写入文件关闭，或是数据库关闭的这种终止操作。只要是函数没有完全运行结束，就不会将内存全部回收，等待执行完谁回收谁。
上下文管理协议 (with 方法)

　　__enter__ 和__exit__
用途或者说好处：
　　1.使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预。
　　2.在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在__exit__中定制自动释放资源的机制，你无须再去关系这个问题，这将大有用处
　　with操作，打开文件就会自定调用执行 __exit__主要是检测 错误，并报异常，只要有异常就不会再往下执行，可在函数下加入 return True 正常执行。操作结束之后清理

	
# __enter__和__exit__
 
class Foo:
    def __enter__(self):  #with 拿到一个对象，触发enter方法
        print('enter')
        return 11111
    def __exit__(self, exc_type, exc_val, exc_tb): #文件打开执行完毕后，执行exit方法
        print('exit')
        print('exc_type',exc_type)  #异常的类型
        print('exc_val',exc_val)    #异常的值
        print('exc_tb',exc_tb)      #异常的内存地址
        return True #清空所有异常，抛异常之后，with后的内容正常执行。
with Foo() as obj:  #执行Foo().__enter__方法得到一个返回值，然后将这个值赋给obj。
    #出现with语句, 对象的__enter__被触发, 有返回值则赋值给as声明的变量
    print('with Foo 的子代码块',obj) #执行with模块字代码
    raise NameError('名字没有定义！')  #只要是报异常，没有处理的话，就意味着with执行的字代码块运行完。触发exit方法，这之后的代码就不会再执行。
    print('##############')
print('**************')
 
#执行结果：
enter
with Foo 的子代码块 11111
exit
exc_type <class 'NameError'>
exc_val 名字没有定义！
exc_tb <traceback object at 0x00000000028EE948>
**************
__call__ 方法

　　__call__ 方法 把对象转换成可执行对象。对象后面加括号，触发执行。类本身就是可执行对象，要不然怎么实例化对象。
　　注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 __call__ 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()

	
class Foo:
    def __init__(self,name):
        self.name = name
    def __call__(self, *args, **kwargs):
        print('__call__')
 
obj = Foo('egon')  # 执行 __init__
#obj()  # 执行 __call__ 对象对去找有没有__call__的绑定方法，有加()就能运行！
#查看是否为可调用对象（可调用对象：名字后加()就能运行）
print(callable(Foo))
print(callable(obj))
#执行结果：
True
True
元类

什么是元类？

　　元类是类的类，是类的模板 

　　元类是用来控制如何创建类的，正如类是创建对象的模板一样

　　元类的实例为类，正如类的实例为对象(f1对象是Foo类的一个实例，Foo类是 type 类的一个实例)

　　***type是python的一个内建元类，用来直接控制生成类，python中任何class定义的类其实都是type类实例化的对象***
1
2
3
4
5
6
7
8
9
10
11
12
13
	
流程：
    type --创建--> 元类 --创建--> 类 --实例化--> 对象
type称为元类，是所有类的类，控制类的。一个类没有声明自己的元类，默认他的元类就是type，可以通过type来创建类
 
创建流程：
 
def func(self):
    print 'hello world'
 
Foo = type('Foo',(object,), {'func': func})
#type第一个参数：类名，指要创建的类      字符串
#type第二个参数：当前类的基类，继承的类  元组
#type第三个参数：类的成员，代表属性和方法  字典
分类: Python之路
好文要顶 关注我 收藏该文
Meet、
关注 - 45
粉丝 - 43
+加关注
0
« 上一篇：linux下Tab及shell 补全python
» 下一篇：python 正则详解
posted @ 2018-01-24 09:53 Meet、 阅读(8) 评论(0) 编辑 收藏
刷新评论刷新页面返回顶部
注册用户登录后才能发表评论，请 登录 或 注册，访问网站首页。
【推荐】超50万VC++源码: 大型组态工控、电力仿真CAD与GIS源码库！
【推荐】云+校园计划邀请好友拼团有礼，奖励多多
【推荐】5分钟完成网站搭建 多种定制镜像，19.6元/月起
tencent0228
最新IT新闻:
· 微软新专利曝光 Surface Phone或支持背部触控
· 支付宝推出新福利：多个城市免费乘公交
· Google Contacts现可通过Google Pay Send转账了
· Fedora将发布物联网版
· 谷歌母公司股价上周5连涨 市值已重回8000亿美元
» 更多新闻...
阿里云0308
最新知识库文章:
· 写给自学者的入门指南
· 和程序员谈恋爱
· 学会学习
· 优秀技术人的管理陷阱
· 作为一个程序员，数学对你到底有多重要
» 更多知识库文章...
<	2018年3月	>
日	一	二	三	四	五	六
25	26	27	28	1	2	3
4	5	6	7	8	9	10
11	12	13	14	15	16	17
18	19	20	21	22	23	24
25	26	27	28	29	30	31
1	2	3	4	5	6	7
常用链接

    我的随笔
    我的评论
    我的参与
    最新评论
    我的标签

我的标签

    JavaScript(7)
    Vue框架(4)
    python目录(1)

随笔分类

    Django(20)
    go
    JS-HTML-JQ(18)
    Liunx(10)
    MySQL(6)
    Python之路(51)
    前端之路(3)

积分与排名

    积分 - 17126
    排名 - 21607

最新评论

    1. Re:python/MySQL（索引、执行计划、BDA、分页）
    @培伦 共同学习...
    --Meet、
    2. Re:python/MySQL（索引、执行计划、BDA、分页）
    谢谢
    --培伦

阅读排行榜

    1. Python/练习题(1868)
    2. Python/ selectors模块及队列(1252)
    3. Python/MySQL（三、pymysql使用）(1101)
    4. python/基础输出输入用法(668)
    5. python/socket编程之粘包(640)
    6. Python/MySQL（二、表操作以及连接）(495)
    7. python/MySQL（索引、执行计划、BDA、分页）(349)
    8. python目录(281)
    9. python Josnp(跨域)(260)
    10. python/Djangof分页与自定义分页(233)

评论排行榜

    1. python/MySQL（索引、执行计划、BDA、分页）(2)

推荐排行榜

    1. Python/练习题(1)

Copyright ©2018 Meet、
